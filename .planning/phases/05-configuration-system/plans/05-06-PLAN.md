---
phase: 05-configuration-system
plan: 06
type: execute
wave: 4
depends_on: [08-02, 08-03, 08-04, 08-05]
files_modified: [packages/ui/components/SettingsPanel.tsx, packages/ui/utils/storage.ts]
autonomous: true

must_haves:
  truths:
    - "All user settings persist across browser sessions"
    - "Logged-in users see same settings on different devices (if Supabase connected)"
    - "Local-only settings persist per device"
    - "Save failures show clear error message"
    - "Settings load and apply on startup"
    - "No settings are lost on refresh"
  artifacts:
    - path: "packages/ui/utils/storage.ts"
      provides: "Settings persistence utilities"
      contains: "localStorage wrappers, error handling for save failures"
    - path: "packages/ui/components/SettingsPanel.tsx"
      provides: "Settings with error handling and visual feedback"
      contains: "try/catch for localStorage, error state management"
  key_links:
    - from: "all settings inputs"
      to: "localStorage"
      via: "handlePathChange, handleTemplateChange, etc."
      pattern: "localStorage.setItem|getNoteTypePath|setNoteTypePath"
    - from: "settings panel on mount"
      to: "localStorage"
      via: "useEffect with isOpen dependency"
      pattern: "useEffect.*isOpen.*getNoteTypePath|getIdentity"
---

<objective>
Ensure all settings persist properly across sessions with robust error handling, visual feedback, and proper storage layering (localStorage for local settings, Supabase for per-user settings).

Purpose: Implement comprehensive settings persistence with error handling, ensuring users never lose their configuration and receive clear feedback about save status.

Output: Robust settings storage layer with error handling and visual feedback for all save operations.
</objective>

<execution_context>
@C:\Users\Alex\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Alex\.claude\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-configuration-system/08-RESEARCH.md

@.planning/phases/05-configuration-system/plans/05-02-SUMMARY.md
@.planning/phases/05-configuration-system/plans/05-03-SUMMARY.md
@.planning/phases/05-configuration-system/plans/05-04-SUMMARY.md
@.planning/phases/05-configuration-system/plans/05-05-SUMMARY.md
@packages/ui/components/SettingsPanel.tsx
@packages/ui/utils/storage.ts
@packages/ui/utils/identity.ts
</context>

<tasks>

<task type="auto">
  <name>Add comprehensive error handling for localStorage operations</name>
  <files>packages/ui/utils/storage.ts, packages/ui/components/SettingsPanel.tsx</files>
  <action>
Add error handling wrapper functions for localStorage operations:

1. First, read packages/ui/utils/storage.ts to understand current implementation

2. Add safe localStorage wrapper functions (if not already present):
```tsx
// In storage.ts, add:
export function safeSetItem(key: string, value: string): { success: boolean; error?: string } {
  try {
    localStorage.setItem(key, value);
    return { success: true };
  } catch (error) {
    console.error(`Failed to save ${key}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

export function safeGetItem(key: string): { success: boolean; value?: string; error?: string } {
  try {
    const value = localStorage.getItem(key);
    return { success: true, value: value || undefined };
  } catch (error) {
    console.error(`Failed to load ${key}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
```

3. Update settings save functions to use error wrappers:
```tsx
// For example, update setNoteTypePath:
export function setNoteTypePath(tipo: string, path: string): { success: boolean; error?: string } {
  const key = `noteTypePath_${tipo}`;
  const result = safeSetItem(key, path);

  if (!result.success) {
    // Return error for UI to handle
    return result;
  }

  // Also update the general paths object
  const paths = getAllNoteTypePaths();
  paths[tipo] = path;
  safeSetItem('noteTypePaths', JSON.stringify(paths));

  return { success: true };
}

// Similar pattern for:
// - setNoteTypeTemplate
// - setNotePath
// - updateDisplayName
// - etc.
```

4. Update return types or add error tracking to existing functions.

This provides error information back to the UI for display to users.
  </action>
  <verify>storage.ts has safeSetItem and safeGetItem functions with try/catch, and settings functions return error status</verify>
  <done>Error handling wrappers added to all localStorage operations</done>
</task>

<task type="auto">
  <name>Add error state and visual feedback to SettingsPanel</name>
  <files>packages/ui/components/SettingsPanel.tsx</files>
  <action>
Add error state management and visual feedback for save operations:

1. Add error state to SettingsPanel:
```tsx
const [saveErrors, setSaveErrors] = useState<Record<string, string>>({});
const [saveSuccess, setSaveSuccess] = useState<Record<string, boolean>>({});
```

2. Update handlePathChange to handle errors:
```tsx
const handlePathChange = (tipo: string, path: string) => {
  setNotePaths(prev => ({ ...prev, [tipo]: path }));

  // Save to localStorage with error handling
  const result = setNoteTypePath(tipo, path);

  if (result.success) {
    // Show success feedback
    setSaveSuccess(prev => ({ ...prev, [`${tipo}-path`]: true }));
    setSaveErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[`${tipo}-path`];
      return newErrors;
    });

    // Clear success after 2 seconds
    setTimeout(() => {
      setSaveSuccess(prev => {
        const newSuccess = { ...prev };
        delete newSuccess[`${tipo}-path`];
        return newSuccess;
      });
    }, 2000);

    // Update general note path
    setNotePath(path);
    onNotePathChange?.(path);
  } else {
    // Show error
    setSaveErrors(prev => ({
      ...prev,
      [`${tipo}-path`]: result.error || 'Erro ao salvar'
    }));
  }
};
```

3. Similar updates for:
   - handleTemplateChange
   - handleDisplayNameChange
   - toggleHook
   - Language selection

4. Add error indicators in the UI (for CategoryContent):
```tsx
<div className="relative">
  <input
    type="text"
    value={notePaths[tipo] || ''}
    onChange={(e) => handlePathChange(tipo, e.target.value)}
    className={`
      w-full px-3 py-2.5 pr-10 bg-background rounded-lg text-sm
      border ${
        saveErrors[`${tipo}-path`]
          ? 'border-red-500'
          : saveSuccess[`${tipo}-path`]
          ? 'border-green-500'
          : 'border-border'
      }
      focus:border-primary focus:ring-2 focus:ring-primary/20 focus:outline-none
      font-mono transition-all
    `}
  />
  {saveSuccess[`${tipo}-path`] && !saveErrors[`${tipo}-path`] && (
    <div className="absolute right-3 top-1/2 -translate-y-1/2">
      <svg className="w-4 h-4 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
      </svg>
    </div>
  )}
  {saveErrors[`${tipo}-path`] && (
    <div className="absolute right-3 top-1/2 -translate-y-1/2">
      <svg className="w-4 h-4 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </div>
  )}
</div>
{saveErrors[`${tipo}-path`] && (
  <p className="text-[10px] text-red-500 mt-1">
    {saveErrors[`${tipo}-path`]}
  </p>
)}
```

5. Add global error toast for critical failures:
```tsx
{Object.values(saveErrors).some(e => e) && (
  <div className="fixed bottom-4 right-4 z-[60] bg-red-500 text-white px-4 py-3 rounded-lg shadow-xl flex items-center gap-3">
    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
    <div>
      <p className="text-sm font-medium">Erro ao salvar configurações</p>
      <p className="text-xs opacity-90">Verifique o espaço disponível no navegador</p>
    </div>
  </div>
)}
```
  </action>
  <verify>SettingsPanel shows green checkmark on success, red X on error, with error messages displayed below affected fields</verify>
  <done>Visual feedback for save operations with error handling implemented</done>
</task>

<task type="auto">
  <name>Ensure all settings load correctly on startup</name>
  <files>packages/ui/components/SettingsPanel.tsx</files>
<action>
Verify and improve settings loading on mount:

1. Review the current useEffect that loads settings (around line 76-106):
```tsx
useEffect(() => {
  if (isOpen) {
    setIdentity(getIdentity());
    setDisplayNameState(getDisplayName());
    setAnonymousIdentity(getAnonymousIdentity());

    // Load all saved paths and templates
    const noteTypes = getNoteTypesByCategory();
    const paths: Record<string, string> = {};
    const templates: Record<string, string> = {};

    [...noteTypes.terceiros, ...noteTypes.atomica, ...noteTypes.organizacional, ...noteTypes.alex].forEach(({ tipo }) => {
      paths[tipo] = getNoteTypePath(tipo);
      templates[tipo] = getNoteTypeTemplate(tipo);
    });

    setNotePaths(paths);
    setNoteTemplates(templates);

    // If there's no general note path set, use the first available path
    const currentNotePath = getNotePath();
    if (!currentNotePath || currentNotePath.trim() === '') {
      const firstPath = Object.values(paths).find(p => p.trim() !== '');
      if (firstPath) {
        setNotePath(firstPath);
        onNotePathChange?.(firstPath);
      }
    }
  }
}, [isOpen, onNotePathChange]);
```

2. Add error handling for loading:
```tsx
useEffect(() => {
  if (isOpen) {
    try {
      // Load identity with fallback
      setIdentity(getIdentity() || '');
      setDisplayNameState(getDisplayName() || '');
      setAnonymousIdentity(getAnonymousIdentity() || '');

      // Load all saved paths and templates
      const noteTypes = getNoteTypesByCategory();
      const paths: Record<string, string> = {};
      const templates: Record<string, string> = {};

      [...noteTypes.terceiros, ...noteTypes.atomica, ...noteTypes.organizacional, ...noteTypes.alex].forEach(({ tipo }) => {
        try {
          paths[tipo] = getNoteTypePath(tipo) || '';
          templates[tipo] = getNoteTypeTemplate(tipo) || '';
        } catch (error) {
          console.error(`Failed to load settings for ${tipo}:`, error);
          paths[tipo] = '';
          templates[tipo] = '';
        }
      });

      setNotePaths(paths);
      setNoteTemplates(templates);

      // If there's no general note path set, use the first available path
      const currentNotePath = getNotePath();
      if (!currentNotePath || currentNotePath.trim() === '') {
        const firstPath = Object.values(paths).find(p => p.trim() !== '');
        if (firstPath) {
          setNotePath(firstPath);
          onNotePathChange?.(firstPath);
        }
      }
    } catch (error) {
      console.error('Failed to load settings:', error);
      // Set defaults if loading fails
      setNotePaths({});
      setNoteTemplates({});
    }
  }
}, [isOpen, onNotePathChange]);
```

3. Also load hooks from localStorage:
```tsx
// Add to the useEffect:
const savedHooks = localStorage.getItem('obsreview-hooks');
if (savedHooks) {
  try {
    setHooks(JSON.parse(savedHooks));
  } catch (error) {
    console.error('Failed to load hooks:', error);
  }
}
```

4. Also load language preference:
```tsx
const savedLanguage = localStorage.getItem('app-language');
if (savedLanguage) {
  setCurrentLanguage(savedLanguage);
}
```

This ensures all settings load correctly even if some localStorage values are corrupted.
  </action>
  <verify>SettingsPanel loads all settings with error handling, sets defaults if loading fails</verify>
  <done>All settings load correctly on startup with proper error handling</done>
</task>

</tasks>

<verification>
After completion, verify:
1. All settings persist across browser refresh
2. Save operations show visual feedback (green checkmark)
3. Save failures show red X and error message
4. Global error toast appears for multiple save failures
5. Settings load correctly on mount even with corrupted data
6. No settings are lost when switching between categories
7. Export/Import functionality still works with new error handling
8. Load defaults button works correctly
</verification>

<success_criteria>
1. Error handling wrappers in storage.ts
2. Visual feedback for all save operations
3. Error messages displayed for failed saves
4. Settings load with error handling
5. No data loss on refresh or errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-system/plans/05-06-SUMMARY.md` with:
- Error handling implementation details
- Visual feedback approach
- Settings load behavior with error recovery
- Known limitations (e.g., localStorage quota)
</output>
