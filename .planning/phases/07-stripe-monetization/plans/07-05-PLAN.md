07-05: Implement Subscription State Management in Supabase

## Goal
Manage subscription state in Supabase with proper schema and real-time sync for tier changes.

## Requirements
- MONY-06: Subscription state persists and syncs across sessions

## Success Criteria
1. Subscription data stored in Supabase
2. User tier checks work on page load
3. Tier changes reflect immediately across tabs
4. Subscription history tracked for audits
5. Admin can manually adjust tiers if needed

## Implementation Plan

### 1. Create Supabase Tables
```sql
-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  tier TEXT NOT NULL DEFAULT 'free',
  subscription_type TEXT, -- 'monthly', 'yearly', 'lifetime'
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  status TEXT DEFAULT 'active', -- 'active', 'past_due', 'canceled', 'incomplete'
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id)
);

-- Subscription history for audit
CREATE TABLE subscription_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  from_tier TEXT,
  to_tier TEXT NOT NULL,
  event_type TEXT NOT NULL, -- 'upgraded', 'downgraded', 'canceled', 'renewed'
  stripe_event_id TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_history_user_id ON subscription_history(user_id);
CREATE INDEX idx_subscriptions_history_created ON subscription_history(created_at);

-- RLS
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_history ENABLE ROW LEVEL SECURITY;

-- Users can read their own subscription
CREATE POLICY "Users can read own subscription"
  ON subscriptions FOR SELECT
  USING (auth.uid() = user_id);

-- Service role can manage subscriptions
CREATE POLICY "Service role can manage subscriptions"
  ON subscriptions FOR ALL
  USING (auth.role() = 'service_role');

CREATE POLICY "Service role can manage history"
  ON subscription_history FOR ALL
  USING (auth.role() = 'service_role');
```

### 2. Update Subscription Types
```typescript
// packages/collaboration/src/types/tier.ts
export interface Subscription {
  id: string;
  userId: string;
  tier: SubscriptionTier;
  subscriptionType: SubscriptionType | null;
  stripeCustomerId: string | null;
  stripeSubscriptionId: string | null;
  status: SubscriptionStatus;
  currentPeriodStart: string;
  currentPeriodEnd: string | null;
  cancelAtPeriodEnd: boolean;
}

export type SubscriptionStatus =
  | 'active'
  | 'past_due'
  | 'canceled'
  | 'incomplete'
  | 'trialing';
```

### 3. Create Subscription API Functions
```typescript
// apps/portal/src/api/subscription.ts
export async function getUserSubscription(
  userId: string
): Promise<Subscription | null> {
  const { data, error } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', userId)
    .single();

  return data;
}

export async function updateUserSubscription(
  userId: string,
  updates: Partial<Subscription>
): Promise<Subscription> {
  const { data, error } = await supabase
    .from('subscriptions')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('user_id', userId)
    .select()
    .single();

  return data;
}

export async function recordSubscriptionHistory(
  userId: string,
  fromTier: SubscriptionTier | null,
  toTier: SubscriptionTier,
  eventType: string,
  stripeEventId?: string
) {
  await supabase.from('subscription_history').insert({
    user_id: userId,
    from_tier: fromTier,
    to_tier: toTier,
    event_type: eventType,
    stripe_event_id: stripeEventId,
  });
}
```

### 4. Update useSubscription Hook
```typescript
// apps/portal/src/hooks/useSubscription.ts
export function useSubscription() {
  const [subscription, setSubscription] = useState<Subscription | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch from subscriptions table (not user_metadata)
    const fetchSubscription = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const sub = await getUserSubscription(user.id);
      setSubscription(sub);
      setLoading(false);
    };

    fetchSubscription();

    // Real-time subscription for tier changes
    const channel = supabase
      .channel('subscription_changes')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'subscriptions',
        filter: `user_id=eq.${supabase.auth.getUser().data.user?.id}`,
      }, (payload) => {
        setSubscription(payload.new as Subscription);
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  const tier = subscription?.tier || 'free';
  const isPro = tier === 'pro';
  const canAddCollaborators = isPro && subscription?.status === 'active';

  return {
    subscription,
    tier,
    isPro,
    canAddCollaborators,
    loading,
  };
}
```

### 5. Create Admin Functions
```typescript
// apps/portal/src/api/admin/subscription.ts
export async function manuallyUpgradeUser(
  adminUserId: string,
  targetUserId: string,
  tier: SubscriptionTier,
  reason: string
) {
  // For support to manually adjust subscriptions
  // Records in history with admin_note
}
```

## Files to Create
- `apps/portal/src/api/subscription.ts` - Subscription CRUD
- `apps/portal/src/api/admin/subscription.ts` - Admin functions
- Database migration SQL file

## Files to Modify
- `apps/portal/src/hooks/useSubscription.ts` - Use DB instead of metadata
- `apps/portal/src/utils/stripeWebhooks.ts` - Write to DB

## Database Migration
Run SQL in Supabase SQL Editor to create tables.

## Notes
- Real-time subscription ensures immediate tier changes
- History table for audit and debugging
- Admin functions for customer support
- Default to 'free' tier on user creation via trigger
