---
phase: 05-real-time-collaboration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/collaboration/package.json
  - packages/collaboration/src/index.ts
  - packages/collaboration/src/types.ts
  - apps/portal/src/components/PresenceIndicator.tsx
  - apps/portal/src/hooks/usePresence.ts
autonomous: false

must_haves:
  truths:
    - "Liveblocks provides real-time presence for multiple users"
    - "Users can see who else is viewing the same document"
    - "Cursors appear with user avatars and names"
    - "Presence updates automatically when users join/leave"
  artifacts:
    - path: "packages/collaboration/src/index.ts"
      provides: "Liveblocks client setup and room management"
      exports: ["createLiveblocksClient", "enterRoom", "leaveRoom"]
      min_lines: 80
    - path: "apps/portal/src/components/PresenceIndicator.tsx"
      provides: "UI component showing active users"
      min_lines: 60
    - path: "apps/portal/src/hooks/usePresence.ts"
      provides: "React hook for presence state"
      min_lines: 40
  key_links:
    - from: "apps/portal/src/hooks/usePresence.ts"
      to: "packages/collaboration/src/index.ts"
      via: "import"
      pattern: "createLiveblocksClient"
---

<objective>
Integrate Liveblocks for real-time presence and cursor tracking, enabling users to see who else is viewing the document with visual indicators.

**Purpose:** Deliver COLL-01 and COLL-02 requirements - presence indicators and real-time cursors with avatars.

**Output:** Complete Liveblocks integration with presence UI components.
</objective>

<context>
@.planning/phases/05-real-time-collaboration/05-CONTEXT.md
@packages/ui/types/index.ts
@apps/portal/src/components/Layout.tsx

Liveblocks provides:
- Room-based presence (users in same room see each other)
- Cursor position broadcasting
- User info (name, avatar, color)
- Automatic connection management
</context>

<tasks>

<task type="auto">
  <name>Add Liveblocks dependency and create collaboration package</name>
  <files>packages/collaboration/package.json</files>
  <action>
    1. Create `packages/collaboration/package.json`:

    ```json
    {
      "name": "@obsidian-note-reviewer/collaboration",
      "version": "0.1.0",
      "type": "module",
      "description": "Real-time collaboration with Liveblocks",
      "exports": {
        ".": "./src/index.ts",
        "./types": "./src/types.ts"
      },
      "dependencies": {
        "@liveblocks/client": "^2.12.0",
        "@liveblocks/react": "^2.12.0",
        "@obsidian-note-reviewer/ui": "workspace:*"
      },
      "peerDependencies": {
        "react": "^19.0.0"
      }
    }
    ```

    2. Install dependency:
    ```bash
    bun install
    ```
  </action>
  <verify>package.json exists with @liveblocks/client and @liveblocks/react</verify>
  <done>Collaboration package with Liveblocks</done>
</task>

<task type="auto">
  <name>Define collaboration types</name>
  <files>packages/collaboration/src/types.ts</files>
  <action>
    Create `packages/collaboration/src/types.ts`:

    ```typescript
    /**
     * Real-time collaboration types
     */

    export interface LiveblocksConfig {
      publicKey: string;
      baseUrl?: string;
    }

    export interface PresenceUser {
      id: string;
      name: string;
      avatar?: string;
      color: string;
      cursor?: {
        x: number;
        y: number;
      };
    }

    export interface RoomInfo {
      id: string;
      documentId: string;
    }

    export interface PresenceState {
      users: PresenceUser[];
      connected: boolean;
    }
    ```
  </action>
  <verify>types.ts exports PresenceUser, RoomInfo, PresenceState</verify>
  <done>Collaboration type definitions</done>
</task>

<task type="auto">
  <name>Implement Liveblocks client setup</name>
  <files>packages/collaboration/src/index.ts</files>
  <action>
    Create `packages/collaboration/src/index.ts`:

    ```typescript
    /**
     * Liveblocks Integration
     *
     * Real-time presence and cursor tracking for collaborative reviews.
     */

    import { createClient } from '@liveblocks/client';
    import { createRoomContext } from '@liveblocks/react';
    import type { LiveblocksConfig, PresenceUser, RoomInfo, PresenceState } from './types';

    let liveblocksClient: ReturnType<typeof createClient> | null = null;

    /**
     * Get or create Liveblocks client
     */
    export function createLiveblocksClient(config: LiveblocksConfig) {
      if (liveblocksClient) {
        return liveblocksClient;
      }

      liveblocksClient = createClient({
        publicKey: config.publicKey,
        baseUrl: config.baseUrl,
      });

      return liveblocksClient;
    }

    /**
     * Generate a consistent color for user based on their ID
     */
    export function getUserColor(userId: string): string {
      const colors = [
        '#EF4444', '#F97316', '#F59E0B', '#EAB308',
        '#84CC16', '#22C55E', '#10B981', '#14B8A6',
        '#06B6D4', '#0EA5E9', '#3B82F6', '#6366F1',
        '#8B5CF6', '#A855F7', '#D946EF', '#EC4899',
      ];

      let hash = 0;
      for (let i = 0; i < userId.length; i++) {
        hash = userId.charCodeAt(i) + ((hash << 5) - hash);
      }

      return colors[Math.abs(hash) % colors.length];
    }

    /**
     * Get current user info from auth
     */
    export function getCurrentUser(): PresenceUser {
      // Try to get from Supabase session
      const supabase = (window as any)?.supabase;
      if (supabase?.auth?.user()) {
        const user = supabase.auth.user();
        return {
          id: user.id,
          name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'Anônimo',
          avatar: user.user_metadata?.avatar_url,
          color: getUserColor(user.id),
        };
      }

      // Fallback to local storage
      const stored = localStorage.getItem('obsreview-user');
      if (stored) {
        const parsed = JSON.parse(stored);
        return {
          id: parsed.id || 'anonymous',
          name: parsed.name || 'Anônimo',
          avatar: parsed.avatar,
          color: getUserColor(parsed.id || 'anonymous'),
        };
      }

      // Generate anonymous user
      const anonId = `anon-${Math.random().toString(36).slice(2, 8)}`;
      const anonUser: PresenceUser = {
        id: anonId,
        name: 'Visitante',
        color: getUserColor(anonId),
      };

      localStorage.setItem('obsreview-user', JSON.stringify({
        id: anonId,
        name: 'Visitante',
      }));

      return anonUser;
    }

    /**
     * Enter a collaboration room
     */
    export function enterRoom(roomId: string) {
      const client = createLiveblocksClient({
        publicKey: import.meta.env.VITE_LIVEBLOCKS_PUBLIC_KEY || 'pk-dev_xxxxxxxxxxxxx',
      });

      return client.enterRoom(roomId, {
        initialPresence: getCurrentUser(),
      });
    }

    /**
     * Leave current room
     */
    export function leaveRoom(roomId: string) {
      const client = createLiveblocksClient({
        publicKey: import.meta.env.VITE_LIVEBLOCKS_PUBLIC_KEY || 'pk-dev_xxxxxxxxxxxxx',
      });

      return client.leaveRoom(roomId);
    }

    // Export types
    export type { LiveblocksConfig, PresenceUser, RoomInfo, PresenceState };
    ```
  </action>
  <verify>index.ts exports createLiveblocksClient, enterRoom, leaveRoom, getCurrentUser, getUserColor</verify>
  <done>Liveblocks client setup and utilities</done>
</task>

<task type="auto">
  <name>Create usePresence React hook</name>
  <files>apps/portal/src/hooks/usePresence.ts</files>
  <action>
    Create `apps/portal/src/hooks/usePresence.ts`:

    ```typescript
    /**
     * Presence Hook
     *
     * React hook for real-time presence state using Liveblocks.
     */

    import { useEffect, useState } from 'react';
    import type { PresenceUser } from '@obsidian-note-reviewer/collaboration/types';

    export interface UsePresenceOptions {
      roomId: string;
      enabled?: boolean;
    }

    export interface PresenceState {
      others: PresenceUser[];
      connected: boolean;
    }

    export function usePresence({ roomId, enabled = true }: UsePresenceOptions) {
      const [state, setState] = useState<PresenceState>({
        others: [],
        connected: false,
      });

      useEffect(() => {
        if (!enabled || !roomId) return;

        // Dynamic import to avoid SSR issues
        let cleanup: (() => void) | null = null;

        const initPresence = async () => {
          try {
            const { enterRoom, leaveRoom } = await import('@obsidian-note-reviewer/collaboration');

            const room = enterRoom(roomId);

            // Subscribe to presence updates
            const unsubscribe = room.subscribe('others', (others) => {
              setState({
                others: others.map((other: any) => other.presence),
                connected: true,
              });
            });

            cleanup = () => {
              unsubscribe();
              leaveRoom(roomId);
            };
          } catch (error) {
            console.error('Failed to initialize presence:', error);
            setState((prev) => ({ ...prev, connected: false }));
          }
        };

        initPresence();

        return () => {
          if (cleanup) cleanup();
        };
      }, [roomId, enabled]);

      return state;
    }
    ```
  </action>
  <verify>usePresence hook returns {others, connected}</verify>
  <done>React hook for presence state</done>
</task>

<task type="auto">
  <name>Create PresenceIndicator component</name>
  <files>apps/portal/src/components/PresenceIndicator.tsx</files>
  <action>
    Create `apps/portal/src/components/PresenceIndicator.tsx`:

    ```typescript
    /**
     * Presence Indicator Component
     *
     * Shows active users in the current document with avatars.
     */

    import React from 'react';
    import { usePresence } from '../hooks/usePresence';

    export interface PresenceIndicatorProps {
      roomId: string;
      currentUserId?: string;
    }

    export function PresenceIndicator({ roomId, currentUserId }: PresenceIndicatorProps) {
      const { others, connected } = usePresence({ roomId });

      if (!connected || others.length === 0) {
        return null;
      }

      return (
        <div className="presence-indicator flex items-center gap-2 px-3 py-2 bg-white dark:bg-gray-800 rounded-lg shadow-sm">
          <div className="flex items-center">
            <span className="inline-flex h-2 w-2 rounded-full bg-green-500 mr-2 animate-pulse" />
            <span className="text-xs text-gray-600 dark:text-gray-400">
              {others.length} {others.length === 1 ? 'outro' : 'outros'} visualizando
            </span>
          </div>

          <div className="flex -space-x-2">
            {others.slice(0, 5).map((other) => (
              <UserAvatar key={other.id} user={other} />
            ))}

            {others.length > 5 && (
              <div className="flex items-center justify-center w-8 h-8 rounded-full bg-gray-200 dark:bg-gray-700 text-xs text-gray-600 dark:text-gray-300 font-medium">
                +{others.length - 5}
              </div>
            )}
          </div>
        </div>
      );
    }

    interface UserAvatarProps {
      user: {
        id: string;
        name: string;
        avatar?: string;
        color: string;
      };
    }

    function UserAvatar({ user }: UserAvatarProps) {
      const initials = user.name
        .split(' ')
        .map((n) => n[0])
        .join('')
        .toUpperCase()
        .slice(0, 2);

      return (
        <div
          className="w-8 h-8 rounded-full flex items-center justify-center text-white text-xs font-medium border-2 border-white dark:border-gray-800"
          style={{ backgroundColor: user.color }}
          title={user.name}
        >
          {user.avatar ? (
            <img
              src={user.avatar}
              alt={user.name}
              className="w-full h-full rounded-full object-cover"
            />
          ) : (
            <span>{initials}</span>
          )}
        </div>
      );
    }

    export default PresenceIndicator;
    ```
  </action>
  <verify>PresenceIndicator shows avatars of other users</verify>
  <done>UI component for presence display</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Liveblocks integration with presence indicators</what-built>
  <how-to-verify>
    1. Set VITE_LIVEBLOCKS_PUBLIC_KEY in .env (get from liveblocks.io)
    2. Start portal: `cd apps/portal && bun run dev`
    3. Open same document in two browser windows (incognito for different session)
    4. Verify presence indicator appears in both windows
    5. Verify avatars show with different colors
    6. Verify count updates when opening/closing windows

    Expected outcomes:
    - Presence indicator shows "1 outro visualizando" with avatar
    - Different users get different colors
    - Presence updates in real-time
  </how-to-verify>
  <resume-signal>Type "approved" if presence works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] Collaboration package created with Liveblocks dependency
- [ ] createLiveblocksClient() initializes client with config
- [ ] getCurrentUser() returns user with name, avatar, color
- [ ] getUserColor() generates consistent colors per user ID
- [ ] usePresence hook returns {others, connected}
- [ ] PresenceIndicator shows avatars of other users
- [ ] E2E test confirms presence in multiple windows
</verification>

<success_criteria>
1. Presence indicators show who else is viewing (COLL-01)
2. Real-time cursors with avatars display (COLL-02)
3. Users see each other immediately when joining
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-collaboration/plans/05-01-SUMMARY.md`
</output>

---

**Plan created:** 2026-02-06
**Estimated duration:** 30 min
**Complexity:** Medium (Liveblocks integration, React hooks, real-time state)
