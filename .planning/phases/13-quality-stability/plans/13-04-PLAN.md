# 13-04: Create Automated Test Suite

## Goal
Create automated tests covering critical application features.

## Requirements
- QUAL-05: Automated tests cover critical features

## Success Criteria
1. Unit tests for utility functions
2. Component tests for UI components
3. Integration tests for key workflows
4. Tests run in CI/CD pipeline
5. Test coverage > 70%

## Implementation

### Test Framework Setup

#### Install Testing Dependencies
```bash
bun add -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

#### Vitest Configuration
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './test/setup.ts',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'test/',
        '**/*.test.{ts,tsx}',
        '**/*.spec.{ts,tsx}',
      ],
    },
  },
});
```

#### Test Setup
```typescript
// test/setup.ts
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';

afterEach(() => {
  cleanup();
});
```

### Unit Tests

#### Example: Utility Function Test
```typescript
// packages/core/src/lib/utils.test.ts
import { describe, it, expect } from 'vitest';
import { generateSlug, validateSlug } from './utils';

describe('generateSlug', () => {
  it('should convert title to slug', () => {
    expect(generateSlug('Hello World')).toBe('hello-world');
  });

  it('should remove accents', () => {
    expect(generateSlug('Café')).toBe('cafe');
  });

  it('should remove special characters', () => {
    expect(generateSlug('Hello @ World!')).toBe('hello-world');
  });

  it('should handle empty string', () => {
    expect(generateSlug('')).toBe('');
  });
});

describe('validateSlug', () => {
  it('should validate correct slug', () => {
    expect(validateSlug('valid-slug', []).isValid).toBe(true);
  });

  it('should reject too short slug', () => {
    expect(validateSlug('ab', []).isValid).toBe(false);
  });

  it('should detect duplicate slug', () => {
    expect(validateSlug('existing', ['existing']).isAvailable).toBe(false);
  });
});
```

### Component Tests

#### Example: Button Component Test
```typescript
// packages/ui/src/components/Button.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { Button } from './Button';

describe('Button', () => {
  it('should render children', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('should call onClick when clicked', async () => {
    const handleClick = vi.fn();
    const user = userEvent.setup();

    render(<Button onClick={handleClick}>Click me</Button>);

    await user.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should be disabled when loading is true', () => {
    render(<Button loading>Loading</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('should show spinner when loading', () => {
    render(<Button loading>Loading</Button>);
    expect(screen.getByRole('status')).toBeInTheDocument();
  });
});
```

### Integration Tests

#### Example: Annotation Flow Test
```typescript
// apps/portal/src/__tests__/annotationFlow.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { AnnotationPanel } from '../components/AnnotationPanel';

describe('Annotation Flow', () => {
  it('should add annotation and display in list', async () => {
    const mockAddAnnotation = vi.fn();

    render(
      <AnnotationPanel
        annotations={[]}
        onAddAnnotation={mockAddAnnotation}
      />
    );

    // Click add button
    await user.click(screen.getByText('Adicionar Anotação'));

    // Fill form
    await user.type(screen.getByPlaceholderText('Sua anotação'), 'Test annotation');

    // Submit
    await user.click(screen.getByText('Salvar'));

    await waitFor(() => {
      expect(mockAddAnnotation).toHaveBeenCalledWith('Test annotation');
    });
  });
});
```

### Test Suites to Create

#### Core Utilities
```
packages/core/src/lib/
  - utils.test.ts
  - slug.test.ts
  - validation.test.ts
```

#### UI Components
```
packages/ui/src/components/
  - Button.test.tsx
  - Input.test.tsx
  - Card.test.tsx
  - Modal.test.tsx
  - EmptyState.test.tsx
  - Spinner.test.tsx
```

#### Annotation System
```
packages/annotation/src/
  - useAnnotationStore.test.ts
  - useAnnotationHistory.test.ts
  - annotationUtils.test.ts
```

#### Critical Workflows
```
apps/portal/src/__tests__/
  - authenticationFlow.test.tsx
  - annotationFlow.test.tsx
  - documentSharing.test.tsx
  - subscriptionFlow.test.tsx
```

### Test Scripts

#### Package.json
```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:run": "vitest run"
  }
}
```

### Coverage Targets

#### Minimum Coverage by Type
- Utilities: 90%
- Components: 80%
- Hooks: 75%
- Integration: 60%
- Overall: 70%

#### CI/CD Integration
```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: oven-sh/setup-bun@v1
      - run: bun install
      - run: bun test:coverage
      - uses: codecov/codecov-action@v3
```

## Files to Create
- `vitest.config.ts` - Test configuration
- `test/setup.ts` - Test setup
- `test/tsconfig.json` - Test TypeScript config
- Multiple test files for each module

## Files to Modify
- `package.json` - Add test scripts
- `.github/workflows/test.yml` - CI test workflow

## Best Practices

### Writing Tests
1. **Arrange, Act, Assert** pattern
2. Test user behavior, not implementation
3. Use descriptive test names
4. One assertion per test (when possible)
5. Mock external dependencies

### Component Testing
1. Test user interactions
2. Test different props combinations
3. Test error states
4. Test loading states
5. Test accessibility

### Integration Testing
1. Test complete workflows
2. Test with real dependencies (when possible)
3. Test error scenarios
4. Test edge cases

## Running Tests

### All Tests
```bash
bun test
```

### Watch Mode
```bash
bun test --watch
```

### Coverage
```bash
bun test:coverage
```

### Specific File
```bash
bun test Button.test.tsx
```

## Notes
- Use Vitest for fast unit tests
- Mock Supabase in tests
- Use userEvent for realistic interactions
- Keep tests simple and focused
- Aim for 70%+ coverage
