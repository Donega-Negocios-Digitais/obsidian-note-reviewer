# 13-05: Performance Audit and Fix Memory Leaks

## Goal
Conduct performance audit and fix memory leaks for optimal performance.

## Requirements
- QUAL-06: Application performs without memory leaks and optimized load times

## Success Criteria
1. Lighthouse performance score > 90
2. No memory leaks detected
3. Fast initial load (< 3s)
4. Fast time to interactive (< 5s)
5. No layout shift (CLS < 0.1)
6. Smooth 60fps animations

## Performance Metrics

### Core Web Vitals
```
LCP (Largest Contentful Paint): < 2.5s
FID (First Input Delay): < 100ms
CLS (Cumulative Layout Shift): < 0.1
```

### Additional Metrics
```
TTFB (Time to First Byte): < 600ms
FCP (First Contentful Paint): < 1.8s
TTI (Time to Interactive): < 3.8s
```

## Audit Tools

### Chrome DevTools
1. Performance tab
2. Memory profiler
3. Network tab
4. Lighthouse

### Command Line
```bash
# Lighthouse CI
bun add -D @lhci/cli
lhci autorun --collect.url=http://localhost:5173

# Bundle analyzer
bun add -D rollup-plugin-visualizer
```

## Common Issues and Fixes

### Memory Leaks

#### 1. Unmounted Component State Updates
```typescript
// Problem: setState after unmount
useEffect(() => {
  const interval = setInterval(() => {
    setData(fetchData());
  }, 1000);

  return () => clearInterval(interval);
}, []);
```

#### 2. Event Listeners Not Cleaned Up
```typescript
// Problem: Event listener not removed
useEffect(() => {
  const handler = () => console.log('resize');
  window.addEventListener('resize', handler);

  return () => window.removeEventListener('resize', handler);
}, []);
```

#### 3. Large Objects in State
```typescript
// Problem: Storing large objects
// Solution: Use useRef or external storage
const largeDataRef = useRef<LargeData>(null);
```

#### 4. Unclosed Subscriptions
```typescript
// Problem: Subscription not closed
useEffect(() => {
  const subscription = observable.subscribe(data => {
    setState(data);
  });

  return () => subscription.unsubscribe();
}, []);
```

### Bundle Size Issues

#### Code Splitting
```typescript
// Lazy load routes
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));

// Lazy load components
const HeavyComponent = lazy(() => import('./components/HeavyComponent'));
```

#### Tree Shaking
```typescript
// Import specific functions
import { debounce } from 'lodash-es';

// Instead of entire library
import _ from 'lodash'; // Avoid
```

#### Dynamic Imports
```typescript
// Load libraries only when needed
const loadChartLibrary = async () => {
  const Chart = await import('chart.js');
  return Chart;
};
```

### Rendering Performance

#### Memoization
```typescript
// Memoize expensive computations
const expensiveValue = useMemo(() => {
  return computeExpensive(data);
}, [data]);

// Memoize callbacks
const handleClick = useCallback(() => {
  doSomething(dependency);
}, [dependency]);

// Memoize components
const ExpensiveComponent = memo(({ data }) => {
  return <div>{/* ... */}</div>;
});
```

#### Virtualization
```typescript
// For long lists
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={items.length}
  itemSize={50}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>{items[index]}</div>
  )}
</FixedSizeList>
```

#### Pagination
```typescript
// Instead of loading all items
const paginatedItems = items.slice(page * pageSize, (page + 1) * pageSize);
```

### Network Performance

#### Image Optimization
```typescript
// Use WebP format
<picture>
  <source srcSet="image.webp" type="image/webp" />
  <img src="image.jpg" alt="..." loading="lazy" />
</picture>
```

#### API Optimization
```typescript
// Debounce search input
const debouncedSearch = useDebounce(searchTerm, 300);

// Cancel previous requests
const abortController = new AbortController();
fetch(url, { signal: abortController.signal });
```

#### Caching Strategy
```typescript
// Cache API responses
const cache = new Map();

async function fetchWithCache(url: string) {
  if (cache.has(url)) {
    return cache.get(url);
  }
  const data = await fetch(url);
  cache.set(url, data);
  return data;
}
```

## Performance Monitoring

### Performance Observer
```typescript
// Track performance metrics
export function usePerformanceObserver() {
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.log('[Performance]', entry.name, entry.duration);
      }
    });

    observer.observe({ entryTypes: ['measure', 'navigation', 'resource'] });

    return () => observer.disconnect();
  }, []);
}
```

### Web Vitals Tracking
```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function reportWebVitals(metric: any) {
  // Send to analytics
  console.log('[Web Vital]', metric.name, metric.value);

  // Send to analytics service
  // analytics.track('web_vital', metric);
}

getCLS(reportWebVitals);
getFID(reportWebVitals);
getFCP(reportWebVitals);
getLCP(reportWebVitals);
getTTFB(reportWebVitals);
```

## Optimization Checklist

### Images
- [ ] All images have width/height attributes
- [ ] Images are optimized (WebP, compressed)
- [ ] Lazy loading for below-fold images
- [ ] Responsive images with srcset

### JavaScript
- [ ] Code splitting implemented
- [ ] Tree shaking enabled
- [ ] Lazy loading routes
- [ ] Memoized expensive components
- [ ] Debounced event handlers

### CSS
- [ ] Critical CSS inlined
- [ ] Non-critical CSS deferred
- [ ] Unused CSS removed
- [ ] CSS minified in production

### Network
- [ ] HTTP/2 enabled
- [ ] Gzip/brotli compression
- [ ] CDN for static assets
- [ ] API responses cached
- [ ] Prefetch critical resources

## Files to Create
- `packages/core/src/utils/usePerformanceObserver.ts`
- `packages/core/src/utils/reportWebVitals.ts`
- Performance test files

## Files to Modify
- Components with performance issues
- Large component files (split)
- Images without dimensions

## Testing

### Lighthouse CI
```bash
npx lighthouse https://localhost:5173 --view
```

### Memory Profiling
1. Open Chrome DevTools
2. Go to Memory tab
3. Take heap snapshot
4. Perform actions
5. Take another snapshot
6. Compare for leaks

### Performance Profiling
1. Open Chrome DevTools
2. Go to Performance tab
3. Record
4. Perform actions
5. Stop recording
6. Analyze timeline

## Targets

### Bundle Size
- Initial JS: < 200KB gzipped
- Initial CSS: < 20KB gzipped
- Total initial: < 250KB gzipped

### Load Time
- TTFB: < 600ms
- FCP: < 1.8s
- LCP: < 2.5s
- TTI: < 3.8s

### Runtime
- 60fps animations
- < 100ms input response
- No main thread blocking (> 50ms)
