# 13-03: Build Undo/Redo System for Annotations

## Goal
Implement undo/redo system for all annotation operations.

## Requirements
- QUAL-04: Undo/redo system works for all annotation operations

## Success Criteria
1. All annotation actions can be undone
2. Redo restores previously undone actions
3. History persists during session
4. Keyboard shortcuts (Ctrl+Z, Ctrl+Y, Ctrl+Shift+Z)
5. Visual indicator of undo/redo availability

## Implementation

### History State Structure
```typescript
// packages/annotation/src/types/history.ts
export interface HistoryState {
  annotations: Annotation[];
  timestamp: number;
}

export interface HistoryEntry {
  id: string;
  action: string;
  description: string;
  before: HistoryState;
  after: HistoryState;
  timestamp: number;
}
```

### History Manager
```typescript
// packages/annotation/src/managers/historyManager.ts
export class AnnotationHistoryManager {
  private past: HistoryEntry[] = [];
  private future: HistoryEntry[] = [];
  private maxEntries = 50;

  canUndo(): boolean {
    return this.past.length > 0;
  }

  canRedo(): boolean {
    return this.future.length > 0;
  }

  addEntry(entry: HistoryEntry): void {
    // Add to past
    this.past.push(entry);

    // Clear future (new action branches)
    this.future = [];

    // Limit history size
    if (this.past.length > this.maxEntries) {
      this.past.shift();
    }
  }

  undo(): HistoryState | null {
    const entry = this.past.pop();
    if (!entry) return null;

    // Add to future for redo
    this.future.push(entry);

    // Return before state
    return entry.before;
  }

  redo(): HistoryState | null {
    const entry = this.future.pop();
    if (!entry) return null;

    // Add back to past
    this.past.push(entry);

    // Return after state
    return entry.after;
  }

  clear(): void {
    this.past = [];
    this.future = [];
  }
}
```

### Hook for History
```typescript
// packages/annotation/src/hooks/useAnnotationHistory.ts
export function useAnnotationHistory() {
  const [history] = useState(() => new AnnotationHistoryManager());
  const { annotations, setAnnotations } = useAnnotationStore();

  const undo = useCallback(() => {
    const state = history.undo();
    if (state) {
      setAnnotations(state.annotations);
    }
  }, [history, setAnnotations]);

  const redo = useCallback(() => {
    const state = history.redo();
    if (state) {
      setAnnotations(state.annotations);
    }
  }, [history, setAnnotations]);

  const addHistoryEntry = useCallback((
    action: string,
    before: Annotation[],
    after: Annotation[]
  ) => {
    history.addEntry({
      id: `hist-${Date.now()}`,
      action,
      description: getActionDescription(action),
      before: { annotations: before, timestamp: Date.now() },
      after: { annotations: after, timestamp: Date.now() },
      timestamp: Date.now(),
    });
  }, [history]);

  return {
    canUndo: history.canUndo(),
    canRedo: history.canRedo(),
    undo,
    redo,
    addHistoryEntry,
  };
}
```

### Action Descriptions (Portuguese)
```typescript
function getActionDescription(action: string): string {
  const descriptions: Record<string, string> = {
    'annotation.add': 'Adicionar anotação',
    'annotation.edit': 'Editar anotação',
    'annotation.delete': 'Excluir anotação',
    'annotation.status': 'Alterar status',
    'comment.add': 'Adicionar comentário',
    'comment.delete': 'Excluir comentário',
  };
  return descriptions[action] || action;
}
```

### Keyboard Shortcuts
```typescript
// packages/ui/src/hooks/useKeyboardShortcuts.ts
export function useKeyboardShortcuts() {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Undo: Ctrl+Z or Cmd+Z
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        // Trigger undo
      }

      // Redo: Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        // Trigger redo
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
}
```

### Undo/Redo Buttons
```typescript
// packages/ui/src/components/UndoRedo.tsx
export function UndoRedo() {
  const { canUndo, canRedo, undo, redo } = useAnnotationHistory();

  return (
    <div className="flex items-center gap-1">
      <button
        onClick={undo}
        disabled={!canUndo}
        className={cn(
          'p-2 rounded-lg transition-colors',
          canUndo
            ? 'text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800'
            : 'text-gray-400 dark:text-gray-600 cursor-not-allowed'
        )}
        title="Desfazer (Ctrl+Z)"
      >
        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>
      <button
        onClick={redo}
        disabled={!canRedo}
        className={cn(
          'p-2 rounded-lg transition-colors',
          canRedo
            ? 'text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800'
            : 'text-gray-400 dark:text-gray-600 cursor-not-allowed'
        )}
        title="Refazer (Ctrl+Y)"
      >
        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6" />
        </svg>
      </button>
    </div>
  );
}
```

## Integration with Annotation Store

### Wrapper Functions
```typescript
// Wrap annotation actions to track history
export function addAnnotation(annotation: Annotation) {
  const before = getAnnotations();

  // Original add logic
  const newState = addAnnotationToStore(annotation);

  const after = getAnnotations();
  addHistoryEntry('annotation.add', before, after);
}

export function deleteAnnotation(id: string) {
  const before = getAnnotations();

  // Original delete logic
  const newState = deleteAnnotationFromStore(id);

  const after = getAnnotations();
  addHistoryEntry('annotation.delete', before, after);
}
```

## Files to Create
- `packages/annotation/src/types/history.ts` - History types
- `packages/annotation/src/managers/historyManager.ts` - History manager
- `packages/annotation/src/hooks/useAnnotationHistory.ts` - History hook
- `packages/ui/src/components/UndoRedo.tsx` - Undo/redo buttons
- `packages/ui/src/hooks/useKeyboardShortcuts.ts` - Keyboard shortcuts

## Files to Modify
- Annotation store to track history
- All annotation actions to wrap with history

## Actions to Track

### Annotation Operations
- Add annotation
- Edit annotation content
- Delete annotation
- Change status
- Move annotation

### Comment Operations
- Add comment
- Edit comment
- Delete comment
- Resolve comment

## Notes
- Limit history to 50 entries to prevent memory issues
- Clear history on new document load
- Persist history during session only (not localStorage)
- Keyboard shortcuts follow platform conventions
