---
phase: 06-multi-document-review
plan: 02
type: execute
wave: 1
depends_on: ["06-01"]
files_modified:
  - apps/portal/src/hooks/useTabAnnotations.ts
  - apps/portal/src/components/AnnotationStateIndicator.tsx
autonomous: false

must_haves:
  truths:
    - "Annotations are preserved when switching between tabs"
    - "Each tab maintains its own annotation state"
    - "Modified indicator shows when annotations have unsaved changes"
    - "Tab state persists across page refresh"
  artifacts:
    - path: "apps/portal/src/hooks/useTabAnnotations.ts"
      provides: "Per-tab annotation state management"
      exports: ["useTabAnnotations"]
      min_lines: 100
    - path: "apps/portal/src/components/AnnotationStateIndicator.tsx"
      provides: "Visual indicator for unsaved annotation changes"
      min_lines: 50

<objective>
Implement annotation state persistence across tab switches so users don't lose their work when navigating between documents.

**Purpose:** Deliver MULT-02 requirement - annotation state persists across tab switches.

**Output:** Complete per-tab annotation state with persistence and visual indicators.
</objective>

<tasks>

<task type="auto">
  <name>Create useTabAnnotations hook</name>
  <files>apps/portal/src/hooks/useTabAnnotations.ts</files>
  <action>
    Create `apps/portal/src/hooks/useTabAnnotations.ts`:

    ```typescript
    /**
     * Tab Annotations Hook
     *
     * Manages annotation state per tab with persistence.
     */

    import { useState, useCallback, useRef } from 'react';
    import type { Annotation } from '@obsidian-note-reviewer/ui/types';

    export interface TabAnnotationState {
      tabId: string;
      annotations: Annotation[];
      originalAnnotations: Annotation[];
      isDirty: boolean;
    }

    export interface UseTabAnnotationsOptions {
      persistKey?: string;
    }

    export function useTabAnnotations(options: UseTabAnnotationsOptions = {}) {
      const { persistKey = 'obsreview-tab-annotations' } = options;

      // Store annotation state per tab
      const [tabStates, setTabStates] = useState<Map<string, TabAnnotationState>>(new Map());

      // Track current active tab
      const activeTabRef = useRef<string | null>(null);

      /**
       * Initialize annotations for a tab
       */
      const initializeTab = useCallback((tabId: string, initialAnnotations: Annotation[]) => {
        setTabStates((prev) => {
          const newMap = new Map(prev);

          if (!newMap.has(tabId)) {
            newMap.set(tabId, {
              tabId,
              annotations: [...initialAnnotations],
              originalAnnotations: [...initialAnnotations],
              isDirty: false,
            });
          }

          return newMap;
        });
      }, []);

      /**
       * Get annotations for a specific tab
       */
      const getTabAnnotations = useCallback((tabId: string): Annotation[] => {
        return tabStates.get(tabId)?.annotations || [];
      }, [tabStates]);

      /**
       * Update annotations for a tab
       */
      const setTabAnnotations = useCallback((tabId: string, annotations: Annotation[]) => {
        setTabStates((prev) => {
          const newMap = new Map(prev);
          const state = newMap.get(tabId);

          if (state) {
            const isDirty = JSON.stringify(annotations) !== JSON.stringify(state.originalAnnotations);
            newMap.set(tabId, {
              ...state,
              annotations,
              isDirty,
            });
          }

          // Persist to sessionStorage for recovery
          try {
            const toPersist = Object.fromEntries(
              Array.from(newMap.entries()).map(([key, value]) => [key, {
                annotations: value.annotations,
                originalAnnotations: value.originalAnnotations,
              }])
            );
            sessionStorage.setItem(persistKey, JSON.stringify(toPersist));
          } catch (e) {
            // SessionStorage might be full or unavailable
            console.warn('Could not persist tab annotations:', e);
          }

          return newMap;
        });
      }, [persistKey]);

      /**
       * Mark a tab as clean (saved)
       */
      const markTabClean = useCallback((tabId: string) => {
        setTabStates((prev) => {
          const newMap = new Map(prev);
          const state = newMap.get(tabId);

          if (state) {
            newMap.set(tabId, {
              ...state,
              originalAnnotations: [...state.annotations],
              isDirty: false,
            });
          }

          return newMap;
        });
      }, []);

      /**
       * Remove a tab's state (cleanup)
       */
      const removeTab = useCallback((tabId: string) => {
        setTabStates((prev) => {
          const newMap = new Map(prev);
          newMap.delete(tabId);
          return newMap;
        });
      }, []);

      /**
       * Check if a tab has unsaved changes
       */
      const isTabDirty = useCallback((tabId: string): boolean => {
        return tabStates.get(tabId)?.isDirty || false;
      }, [tabStates]);

      /**
       * Get dirty tab count
       */
      const getDirtyTabCount = useCallback((): number => {
        let count = 0;
        for (const state of tabStates.values()) {
          if (state.isDirty) count++;
        }
        return count;
      }, [tabStates]);

      return {
        initializeTab,
        getTabAnnotations,
        setTabAnnotations,
        markTabClean,
        removeTab,
        isTabDirty,
        getDirtyTabCount,
        tabStates,
      };
    }
    ```

    Save to `apps/portal/src/hooks/useTabAnnotations.ts`.
  </action>
  <verify>useTabAnnotations hook created</verify>
  <done>Tab annotations hook</done>
</task>

<task type="auto">
  <name>Create AnnotationStateIndicator component</name>
  <files>apps/portal/src/components/AnnotationStateIndicator.tsx</files>
  <action>
    Create `apps/portal/src/components/AnnotationStateIndicator.tsx`:

    ```typescript
    /**
     * Annotation State Indicator Component
     *
     * Visual indicator for unsaved annotation changes.
     */

    import React from 'react';

    export interface AnnotationStateIndicatorProps {
      dirty: boolean;
      count: number;
      onSave?: () => void;
      className?: string;
    }

    export function AnnotationStateIndicator({
      dirty,
      count,
      onSave,
      className = '',
    }: AnnotationStateIndicatorProps) {
      if (!dirty) {
        return (
          <div className={`flex items-center gap-1.5 text-xs text-gray-500 dark:text-gray-400 ${className}`}>
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>{count} anotaç{count === 1 ? 'ão' : 'ões'}</span>
          </div>
        );
      }

      return (
        <div className={`flex items-center gap-2 px-3 py-1.5 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg ${className}`}>
          <svg className="w-4 h-4 text-amber-600 dark:text-amber-400 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
          <span className="text-xs font-medium text-amber-800 dark:text-amber-300">
            {count} anotaç{count === 1 ? 'ão' : 'ões'} não salvas
          </span>
          {onSave && (
            <button
              onClick={onSave}
              className="text-xs text-amber-700 dark:text-amber-400 hover:text-amber-900 dark:hover:text-amber-200 underline font-medium"
            >
              Salvar agora
            </button>
          )}
        </div>
      );
    }

    /**
     * Compact variant for tab display
     */
    export interface AnnotationStateDotProps {
      dirty: boolean;
    }

    export function AnnotationStateDot({ dirty }: AnnotationStateDotProps) {
      if (!dirty) return null;

      return (
        <span
          className="inline-block w-2 h-2 rounded-full bg-blue-600 flex-shrink-0"
          title="Modificado"
        />
      );
    }

    export default AnnotationStateIndicator;
    ```

    Save to `apps/portal/src/components/AnnotationStateIndicator.tsx`.
  </action>
  <verify>AnnotationStateIndicator shows dirty state</verify>
  <done>Annotation state indicator component</done>
</task>

<task type="auto">
  <name>Integrate annotation state into DocumentTabs</name>
  <files>apps/portal/src/components/DocumentTabs.tsx</files>
  <action>
    Update `apps/portal/src/components/DocumentTabs.tsx` to show dirty indicator:

    In the Tab function, add the AnnotationStateDot import and render it:

    ```typescript
    import { AnnotationStateDot } from './AnnotationStateIndicator';

    // Inside Tab component, after the title span:
    <AnnotationStateDot dirty={tab.modified} />
    ```

    This will show the blue dot for modified tabs.
  </action>
  <verify>DocumentTabs shows modified indicator</verify>
  <done>Integrated annotation state indicator</done>
</task>

</tasks>

<verification>
- [ ] useTabAnnotations hook manages per-tab state
- [ ] initializeTab sets up initial annotations
- [ ] setTabAnnotations updates and marks dirty
- [ ] markTabClean resets dirty state
- [ ] removeTab cleans up state
- [ ] AnnotationStateIndicator shows dirty state
- [ ] AnnotationStateDot shows in tab titles
- [ ] sessionStorage persistence for recovery
</verification>

<success_criteria>
1. Annotations persist when switching tabs (MULT-02)
2. Each tab maintains its own state
3. Modified indicator shows unsaved changes
4. State persists across page refresh (via sessionStorage)
</success_criteria>

---

**Plan created:** 2026-02-06
**Estimated duration:** 20 min
**Complexity:** Medium (per-tab state, persistence, dirty tracking)
