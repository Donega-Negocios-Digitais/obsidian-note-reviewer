---
phase: 06-multi-document-review
plan: 03
type: execute
wave: 1
depends_on: ["06-01", "06-02"]
files_modified:
  - apps/portal/src/hooks/useCrossReferences.ts
  - apps/portal/src/components/CrossReferencePanel.tsx
  - apps/portal/src/components/DocumentWorkspace.tsx
autonomous: false

must_haves:
  truths:
    - "Cross-references between open documents are detected and displayed"
    - "User can see which documents reference the current document"
    - "User can navigate to referenced documents directly"
    - "Links in markdown are parsed and highlighted in the UI"
  artifacts:
    - path: "apps/portal/src/hooks/useCrossReferences.ts"
      provides: "Cross-reference detection between open documents"
      exports: ["useCrossReferences"]
      min_lines: 100
    - path: "apps/portal/src/components/CrossReferencePanel.tsx"
      provides: "Visual panel showing document relationships"
      min_lines: 150

<objective>
Implement cross-reference visualization for linked documents so users can see relationships between documents open in tabs.

**Purpose:** Deliver MULT-03 requirement - cross-reference visualization for linked documents.

**Output:** Complete cross-reference detection and visualization panel with navigation.
</objective>

<tasks>

<task type="auto">
  <name>Create useCrossReferences hook</name>
  <files>apps/portal/src/hooks/useCrossReferences.ts</files>
  <action>
    Create `apps/portal/src/hooks/useCrossReferences.ts`:

    ```typescript
    /**
     * Cross References Hook
     *
     * Detects and manages cross-references between open documents.
     */

    import { useMemo, useCallback } from 'react';
    import type { DocumentTab } from './useDocumentTabs';

    export interface CrossReference {
      sourceTabId: string;
      sourceTitle: string;
      targetTabId: string;
      targetTitle: string;
      linkType: 'wiki' | 'markdown' | 'external';
      context?: string; // Surrounding text for context
      line?: number;
    }

    export interface DocumentReferences {
      inbound: CrossReference[]; // References to this document
      outbound: CrossReference[]; // References from this document
    }

    export interface UseCrossReferencesOptions {
      tabs: DocumentTab[];
      activeTabId: string | null;
    }

    export interface UseCrossReferencesReturn {
      getReferences: (tabId: string) => DocumentReferences;
      getAllReferences: () => CrossReference[];
      getGraphEdges: () => Array<{ from: string; to: string; type: string }>;
      findReferencedTabs: (tabId: string) => string[];
    }

    // Wiki link pattern: [[Document Title]] or [[Document Title|Alias]]
    const WIKI_LINK_REGEX = /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;

    // Markdown link pattern: [text](url or path)
    const MD_LINK_REGEX = /\[([^\]]+)\]\(([^)]+)\)/g;

    /**
     * Parse markdown content for links
     */
    function parseLinks(content: string, tabId: string, tabTitle: string): CrossReference[] {
      const refs: CrossReference[] = [];
      const lines = content.split('\n');

      lines.forEach((line, lineIndex) => {
        // Check wiki links
        let match;
        while ((match = WIKI_LINK_REGEX.exec(line)) !== null) {
          const targetTitle = match[1].trim();
          refs.push({
            sourceTabId: tabId,
            sourceTitle: tabTitle,
            targetTabId: '', // Will be resolved by caller
            targetTitle,
            linkType: 'wiki',
            context: line.trim().substring(0, 50),
            line: lineIndex + 1,
          });
        }

        // Reset regex for next iteration
        WIKI_LINK_REGEX.lastIndex = 0;

        // Check markdown links (only for .md files)
        while ((match = MD_LINK_REGEX.exec(line)) !== null) {
          const url = match[2];
          // Only include relative markdown links
          if (url.endsWith('.md') || url.startsWith('./') || url.startsWith('../')) {
            const targetTitle = url.replace(/\.md$/, '').split('/').pop() || url;
            refs.push({
              sourceTabId: tabId,
              sourceTitle: tabTitle,
              targetTabId: '',
              targetTitle,
              linkType: 'markdown',
              context: match[1],
              line: lineIndex + 1,
            });
          }
        }

        MD_LINK_REGEX.lastIndex = 0;
      });

      return refs;
    }

    /**
     * Normalize title for matching (case-insensitive, ignore special chars)
     */
    function normalizeTitle(title: string): string {
      return title
        .toLowerCase()
        .replace(/[^\w\s]/g, '')
        .trim();
    }

    /**
     * Check if two titles match (fuzzy matching)
     */
    function titlesMatch(a: string, b: string): boolean {
      const normA = normalizeTitle(a);
      const normB = normalizeTitle(b);

      // Direct match
      if (normA === normB) return true;

      // Check if one contains the other (for aliases)
      if (normA.includes(normB) || normB.includes(normA)) {
        return Math.abs(normA.length - normB.length) < 10; // Reasonable length difference
      }

      return false;
    }

    /**
     * Hook for detecting cross-references between open documents
     */
    export function useCrossReferences({
      tabs,
      activeTabId,
    }: UseCrossReferencesOptions): UseCrossReferencesReturn {
      // Build title to tabId mapping
      const titleToTabId = useMemo(() => {
        const map = new Map<string, string>();
        tabs.forEach((tab) => {
          map.set(normalizeTitle(tab.title), tab.id);
          // Also store with common variations
          const withoutExt = tab.title.replace(/\.md$/, '');
          map.set(normalizeTitle(withoutExt), tab.id);
        });
        return map;
      }, [tabs]);

      // Parse all links from all tabs
      const allLinks = useMemo(() => {
        const links: CrossReference[] = [];

        tabs.forEach((tab) => {
          if (tab.content) {
            const parsed = parseLinks(tab.content, tab.id, tab.title);
            links.push(...parsed);
          }
        });

        return links;
      }, [tabs]);

      // Resolve links to actual tab IDs
      const resolvedLinks = useMemo(() => {
        return allLinks
          .map((link) => {
            // Try to find matching tab
            for (const [normTitle, tabId] of titleToTabId.entries()) {
              if (titlesMatch(link.targetTitle, normTitle)) {
                return { ...link, targetTabId: tabId };
              }
            }
            return null;
          })
          .filter((link): link is CrossReference => link !== null && link.targetTabId !== '');
      }, [allLinks, titleToTabId]);

      /**
       * Get all references for a specific tab
       */
      const getReferences = useCallback((tabId: string): DocumentReferences => {
        const inbound = resolvedLinks.filter((ref) => ref.targetTabId === tabId);
        const outbound = resolvedLinks.filter((ref) => ref.sourceTabId === tabId);

        return { inbound, outbound };
      }, [resolvedLinks]);

      /**
       * Get all references in the workspace
       */
      const getAllReferences = useCallback((): CrossReference[] => {
        return resolvedLinks;
      }, [resolvedLinks]);

      /**
       * Get graph edges for visualization
       */
      const getGraphEdges = useCallback(() => {
        return resolvedLinks.map((ref) => ({
          from: ref.sourceTabId,
          to: ref.targetTabId,
          type: ref.linkType,
        }));
      }, [resolvedLinks]);

      /**
       * Find all tab IDs that reference the given tab
       */
      const findReferencedTabs = useCallback((tabId: string): string[] => {
        const refs = resolvedLinks.filter((ref) => ref.targetTabId === tabId);
        return [...new Set(refs.map((ref) => ref.sourceTabId))];
      }, [resolvedLinks]);

      return {
        getReferences,
        getAllReferences,
        getGraphEdges,
        findReferencedTabs,
      };
    }

    export default useCrossReferences;
    ```

    Save to `apps/portal/src/hooks/useCrossReferences.ts`.
  </action>
  <verify>useCrossReferences hook created with link parsing</verify>
  <done>Cross references hook</done>
</task>

<task type="auto">
  <name>Create CrossReferencePanel component</name>
  <files>apps/portal/src/components/CrossReferencePanel.tsx</files>
  <action>
    Create `apps/portal/src/components/CrossReferencePanel.tsx`:

    ```typescript
    /**
     * Cross Reference Panel Component
     *
     * Shows inbound and outbound references for the current document.
     */

    import React from 'react';
      type { CrossReference, DocumentReferences } from '../hooks/useCrossReferences';

    export interface CrossReferencePanelProps {
      references: DocumentReferences;
      currentTabId: string;
      onNavigateToTab?: (tabId: string) => void;
      onClose?: () => void;
    }

    /**
     * Panel showing document relationships
     */
    export function CrossReferencePanel({
      references,
      currentTabId,
      onNavigateToTab,
      onClose,
    }: CrossReferencePanelProps) {
      const { inbound, outbound } = references;
      const hasRefs = inbound.length > 0 || outbound.length > 0;

      return (
        <div className="h-full flex flex-col bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700">
          {/* Header */}
          <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
            <h3 className="text-sm font-semibold text-gray-900 dark:text-white">
              Referências
            </h3>
            {onClose && (
              <button
                onClick={onClose}
                className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded transition-colors"
                title="Fechar painel"
              >
                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-4 space-y-6">
            {!hasRefs ? (
              <div className="text-center py-8">
                <svg className="w-12 h-12 mx-auto text-gray-300 dark:text-gray-600 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  Nenhuma referência encontrada
                </p>
              </div>
            ) : (
              <>
                {/* Inbound References */}
                {inbound.length > 0 && (
                  <ReferenceSection
                    title="Referenciado por"
                    references={inbound}
                    direction="inbound"
                    onNavigate={onNavigateToTab}
                    currentTabId={currentTabId}
                  />
                )}

                {/* Outbound References */}
                {outbound.length > 0 && (
                  <ReferenceSection
                    title="Referencia"
                    references={outbound}
                    direction="outbound"
                    onNavigate={onNavigateToTab}
                    currentTabId={currentTabId}
                  />
                )}
              </>
            )}
          </div>
        </div>
      );
    }

    interface ReferenceSectionProps {
      title: string;
      references: CrossReference[];
      direction: 'inbound' | 'outbound';
      onNavigate?: (tabId: string) => void;
      currentTabId: string;
    }

    function ReferenceSection({
      title,
      references,
      direction,
      onNavigate,
      currentTabId,
    }: ReferenceSectionProps) {
      // Group by source/target tab
      const grouped = references.reduce((acc, ref) => {
        const key = direction === 'inbound' ? ref.sourceTabId : ref.targetTabId;
        const title = direction === 'inbound' ? ref.sourceTitle : ref.targetTitle;

        if (!acc[key]) {
          acc[key] = { title, refs: [] };
        }
        acc[key].refs.push(ref);
        return acc;
      }, {} as Record<string, { title: string; refs: CrossReference[] }>);

      return (
        <div>
          <h4 className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-3">
            {title} ({Object.keys(grouped).length})
          </h4>
          <div className="space-y-2">
            {Object.entries(grouped).map(([tabId, { title, refs }]) => (
              <ReferenceCard
                key={tabId}
                tabId={tabId}
                title={title}
                references={refs}
                direction={direction}
                onNavigate={onNavigate}
                isActive={tabId === currentTabId}
              />
            ))}
          </div>
        </div>
      );
    }

    interface ReferenceCardProps {
      tabId: string;
      title: string;
      references: CrossReference[];
      direction: 'inbound' | 'outbound';
      onNavigate?: (tabId: string) => void;
      isActive: boolean;
    }

    function ReferenceCard({
      tabId,
      title,
      references,
      direction,
      onNavigate,
      isActive,
    }: ReferenceCardProps) {
      const linkTypeIcon = references[0]?.linkType === 'wiki' ? (
        <svg className="w-3.5 h-3.5 text-purple-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
        </svg>
      ) : (
        <svg className="w-3.5 h-3.5 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
        </svg>
      );

      return (
        <button
          onClick={() => onNavigate?.(tabId)}
          className={`
            w-full text-left p-3 rounded-lg border transition-all
            ${isActive
              ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800'
              : 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-750'
            }
          `}
        >
          <div className="flex items-start gap-2">
            {linkTypeIcon}
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-gray-900 dark:text-white truncate">
                {title}
              </p>
              {references.length > 1 && (
                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                  {references.length} {references.length === 1 ? 'link' : 'links'}
                </p>
              )}
              {references[0]?.context && (
                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1 line-clamp-2">
                  {references[0].context}
                </p>
              )}
            </div>
            <svg className="w-4 h-4 text-gray-400 flex-shrink-0 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </div>
        </button>
      );
    }

    /**
     * Compact indicator showing reference count
     */
    export interface ReferenceCountBadgeProps {
      count: number;
      onClick?: () => void;
    }

    export function ReferenceCountBadge({ count, onClick }: ReferenceCountBadgeProps) {
      if (count === 0) return null;

      return (
        <button
          onClick={onClick}
          className="flex items-center gap-1.5 px-2 py-1 text-xs bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded-lg text-purple-700 dark:text-purple-300 hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors"
        >
          <svg className="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
          </svg>
          <span className="font-medium">{count}</span>
        </button>
      );
    }

    export default CrossReferencePanel;
    ```

    Save to `apps/portal/src/components/CrossReferencePanel.tsx`.
  </action>
  <verify>CrossReferencePanel shows references</verify>
  <done>Cross reference panel component</done>
</task>

<task type="auto">
  <name>Integrate CrossReferencePanel into DocumentWorkspace</name>
  <files>apps/portal/src/components/DocumentWorkspace.tsx</files>
  <action>
    Update `apps/portal/src/components/DocumentWorkspace.tsx` to add cross-reference panel:

    1. Import the hook and component:
    ```typescript
    import { useCrossReferences } from '../hooks/useCrossReferences';
    import { CrossReferencePanel, ReferenceCountBadge } from './CrossReferencePanel';
    ```

    2. Add state for panel visibility:
    ```typescript
    const [showReferences, setShowReferences] = useState(false);
    ```

    3. Add the hook call after useDocumentTabs:
    ```typescript
    const { getReferences, getAllReferences } = useCrossReferences({
      tabs,
      activeTabId: activeTab?.id || null,
    });
    ```

    4. Add reference button to toolbar:
    ```typescript
    <ReferenceCountBadge
      count={activeTab ? getReferences(activeTab.id).inbound.length : 0}
      onClick={() => setShowReferences(!showReferences)}
    />
    ```

    5. Add the panel in the main layout (after the document grid):
    ```typescript
    {showReferences && activeTab && (
      <div className="w-80 border-l border-gray-200 dark:border-gray-700">
        <CrossReferencePanel
          references={getReferences(activeTab.id)}
          currentTabId={activeTab.id}
          onNavigateToTab={setActiveTab}
          onClose={() => setShowReferences(false)}
        />
      </div>
    )}
    ```

    This adds a togglable right panel showing all references.
  </action>
  <verify>DocumentWorkspace has reference panel toggle</verify>
  <done>Integrated cross-reference panel</done>
</task>

</tasks>

<verification>
- [ ] useCrossReferences parses wiki links [[...]]
- [ ] useCrossReferences parses markdown links [...]()
- [ ] References are resolved to open tabs
- [ ] CrossReferencePanel shows inbound references
- [ ] CrossReferencePanel shows outbound references
- [ ] Navigation works from reference panel
- [ ] ReferenceCountBadge shows in toolbar
- [ ] Panel can be toggled on/off
</verification>

<success_criteria>
1. Cross-references between open documents are displayed (MULT-03)
2. User can see which documents reference the current document
3. User can navigate to referenced documents
4. Both wiki links [[...]] and markdown links [...]() are detected
</success_criteria>

---

**Plan created:** 2026-02-06
**Estimated duration:** 25 min
**Complexity:** Medium (link parsing, fuzzy matching, panel UI)
