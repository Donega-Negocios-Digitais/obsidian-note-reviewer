---
phase: 07-mobile-support
plan: 03
type: execute
wave: 1
depends_on: ["07-01"]
files_modified:
  - apps/portal/src/hooks/useTouchGesture.ts
  - apps/portal/src/components/AnnotationExport.tsx
  - apps/portal/src/components/DocumentTabs.tsx
autonomous: false

must_haves:
  truths:
    - "Touch targets meet minimum size (44x44px) for mobile"
    - "Swipe gestures work for tab switching"
    - "Pull-to-refresh refreshes content"
    - "Long-press context menus available"
    - "Scroll is smooth with proper momentum"
  artifacts:
    - path: "apps/portal/src/hooks/useTouchGesture.ts"
      provides: "Touch gesture recognition hooks"
      exports: ["useSwipe", "useLongPress", "usePullToRefresh"]
      min_lines: 100
    - path: "apps/portal/src/components/TouchButton.tsx"
      provides: "Touch-optimized button component"
      exports: ["TouchButton", "TouchIconButton"]
      min_lines: 80

<objective>
Optimize touch interactions for mobile annotation workflow so the interface feels native and responsive.

**Purpose:** Deliver complete mobile UX with proper touch handling for annotation workflow.

**Output:** Touch-optimized components and gesture recognition hooks.
</objective>

<tasks>

<task type="auto">
  <name>Create useTouchGesture hook</name>
  <files>apps/portal/src/hooks/useTouchGesture.ts</files>
  <action>
    Create `apps/portal/src/hooks/useTouchGesture.ts`:

    ```typescript
    /**
     * Touch Gesture Hook
     *
     * Recognizes touch gestures for mobile interactions.
     */

    import { useRef, useEffect, useCallback, useState } from 'react';

    export interface SwipeHandlers {
      onSwipeLeft?: () => void;
      onSwipeRight?: () => void;
      onSwipeUp?: () => void;
      onSwipeDown?: () => void;
    }

    export interface SwipeOptions {
      threshold?: number;
      restraint?: number;
      allowedTime?: number;
    }

    /**
     * Hook for detecting swipe gestures
     */
    export function useSwipe(handlers: SwipeHandlers, options: SwipeOptions = {}) {
      const {
        threshold = 50,
        restraint = 100,
        allowedTime = 300,
      } = options;

      const touchStart = useRef<{ x: number; y: number; time: number } | null>(null);

      const onTouchStart = useCallback((e: React.TouchEvent) => {
        const touch = e.changedTouches[0];
        touchStart.current = {
          x: touch.screenX,
          y: touch.screenY,
          time: Date.now(),
        };
      }, []);

      const onTouchEnd = useCallback((e: React.TouchEvent) => {
        if (!touchStart.current) return;

        const touch = e.changedTouches[0];
        const distX = touch.screenX - touchStart.current.x;
        const distY = touch.screenY - touchStart.current.y;
        const elapsedTime = Date.now() - touchStart.current.time;

        if (elapsedTime <= allowedTime) {
          if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) {
            if (distX > 0) {
              handlers.onSwipeRight?.();
            } else {
              handlers.onSwipeLeft?.();
            }
          } else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) {
            if (distY > 0) {
              handlers.onSwipeDown?.();
            } else {
              handlers.onSwipeUp?.();
            }
          }
        }

        touchStart.current = null;
      }, [handlers, threshold, restraint, allowedTime]);

      return {
        onTouchStart,
        onTouchEnd,
      };
    }

    export interface LongPressOptions {
      delay?: number;
      threshold?: number;
    }

    /**
     * Hook for detecting long press gestures
     */
    export function useLongPress(
      onLongPress: () => void,
      options: LongPressOptions = {}
    ) {
      const { delay = 500, threshold = 10 } = options;
      const [isLongPress, setIsLongPress] = useState(false);
      const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
      const touchStartRef = useRef<{ x: number; y: number } | null>(null);

      const start = useCallback((e: React.TouchEvent | React.MouseEvent) => {
        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

        touchStartRef.current = { x: clientX, y: clientY };

        timeoutRef.current = setTimeout(() => {
          onLongPress();
          setIsLongPress(true);
        }, delay);
      }, [onLongPress, delay]);

      const clear = useCallback(() => {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
        setIsLongPress(false);
        touchStartRef.current = null;
      }, []);

      const move = useCallback((e: React.TouchEvent | React.MouseEvent) => {
        if (!touchStartRef.current || timeoutRef.current) return;

        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

        const distX = Math.abs(clientX - touchStartRef.current.x);
        const distY = Math.abs(clientY - touchStartRef.current.y);

        if (distX > threshold || distY > threshold) {
          clear();
        }
      }, [clear, threshold]);

      const handlers = {
        onMouseDown: start,
        onMouseUp: clear,
        onMouseMove: move,
        onMouseLeave: clear,
        onTouchStart: start,
        onTouchEnd: clear,
        onTouchMove: move,
      };

      return { handlers, isLongPress };
    }

    export interface PullToRefreshOptions {
      threshold?: number;
      onRefresh: () => void | Promise<void>;
    }

    export interface PullToRefreshReturn {
      pullDistance: number;
      isPulling: boolean;
      isRefreshing: boolean;
      touchHandlers: {
        onTouchStart: (e: React.TouchEvent) => void;
        onTouchMove: (e: React.TouchEvent) => void;
        onTouchEnd: (e: React.TouchEvent) => void;
      };
    }

    /**
     * Hook for pull-to-refresh gesture
     */
    export function usePullToRefresh(options: PullToRefreshOptions): PullToRefreshReturn {
      const { threshold = 80, onRefresh } = options;
      const [pullDistance, setPullDistance] = useState(0);
      const [isPulling, setIsPulling] = useState(false);
      const [isRefreshing, setIsRefreshing] = useState(false);

      const startY = useRef<number>(0);
      const currentY = useRef<number>(0);

      const onTouchStart = useCallback((e: React.TouchEvent) => {
        if (isRefreshing) return;
        const touch = e.touches[0];
        startY.current = touch.clientY;
        currentY.current = touch.clientY;
      }, [isRefreshing]);

      const onTouchMove = useCallback((e: React.TouchEvent) => {
        if (isRefreshing) return;

        const touch = e.touches[0];
        const diff = touch.clientY - startY.current;

        // Only allow pull from top
        if (diff > 0 && window.scrollY === 0) {
          e.preventDefault();
          currentY.current = touch.clientY;
          const distance = Math.min(diff * 0.5, threshold * 1.5);
          setPullDistance(distance);
          setIsPulling(distance >= threshold);
        }
      }, [isRefreshing, threshold]);

      const onTouchEnd = useCallback(async () => {
        if (isPulling && !isRefreshing) {
          setIsRefreshing(true);
          try {
            await onRefresh();
          } finally {
            setIsRefreshing(false);
          }
        }
        setPullDistance(0);
        setIsPulling(false);
      }, [isPulling, isRefreshing, onRefresh]);

      return {
        pullDistance,
        isPulling,
        isRefreshing,
        touchHandlers: {
          onTouchStart,
          onTouchMove,
          onTouchEnd,
        },
      };
    }

    export default useSwipe;
    ```

    Save to `apps/portal/src/hooks/useTouchGesture.ts`.
  </action>
  <verify>useTouchGesture hook created with swipe, long-press, pull-to-refresh</verify>
  <done>Touch gesture hooks</done>
</task>

<task type="auto">
  <name>Create TouchButton component</name>
  <files>apps/portal/src/components/TouchButton.tsx</files>
  <action>
    Create `apps/portal/src/components/TouchButton.tsx`:

    ```typescript
    /**
     * Touch Button Component
     *
     * Touch-optimized buttons with proper tap targets.
     */

    import React from 'react';

    export interface TouchButtonProps {
      children: React.ReactNode;
      onClick?: () => void;
      variant?: 'primary' | 'secondary' | 'ghost';
      size?: 'sm' | 'md' | 'lg';
      disabled?: boolean;
      className?: string;
    }

    /**
     * Touch-friendly button with minimum 44x44px tap target
     */
    export function TouchButton({
      children,
      onClick,
      variant = 'primary',
      size = 'md',
      disabled = false,
      className = '',
    }: TouchButtonProps) {
      const baseStyles = 'min-h-[44px] min-w-[44px] flex items-center justify-center font-medium rounded-lg transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed';

      const variantStyles = {
        primary: 'bg-blue-600 hover:bg-blue-700 text-white shadow-sm',
        secondary: 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-900 dark:text-white',
        ghost: 'bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800 text-gray-700 dark:text-gray-300',
      };

      const sizeStyles = {
        sm: 'px-3 py-2 text-sm',
        md: 'px-4 py-2.5 text-base',
        lg: 'px-6 py-3 text-lg',
      };

      return (
        <button
          onClick={onClick}
          disabled={disabled}
          className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
        >
          {children}
        </button>
      );
    }

    export interface TouchIconButtonProps {
      icon: React.ReactNode;
      label: string;
      onClick?: () => void;
      variant?: 'primary' | 'secondary' | 'ghost';
      size?: 'sm' | 'md' | 'lg';
      disabled?: boolean;
      className?: string;
    }

    /**
     * Touch-friendly icon button
     */
    export function TouchIconButton({
      icon,
      label,
      onClick,
      variant = 'ghost',
      size = 'md',
      disabled = false,
      className = '',
    }: TouchIconButtonProps) {
      const baseStyles = 'min-h-[44px] min-w-[44px] flex items-center justify-center rounded-lg transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed';

      const variantStyles = {
        primary: 'bg-blue-600 hover:bg-blue-700 text-white',
        secondary: 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-900 dark:text-white',
        ghost: 'bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800 text-gray-700 dark:text-gray-300',
      };

      const sizeStyles = {
        sm: 'p-2',
        md: 'p-3',
        lg: 'p-4',
      };

      return (
        <button
          onClick={onClick}
          disabled={disabled}
          aria-label={label}
          className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
        >
          <span className={`${size === 'sm' ? 'text-lg' : size === 'md' ? 'text-xl' : 'text-2xl'}`}>
            {icon}
          </span>
        </button>
      );
    }

    export default TouchButton;
    ```

    Save to `apps/portal/src/components/TouchButton.tsx`.
  </action>
  <verify>TouchButton component created with 44x44px minimum</verify>
  <done>Touch button component</done>
</task>

<task type="auto">
  <name>Add swipe gestures to DocumentTabs</name>
  <files>apps/portal/src/components/DocumentTabs.tsx</files>
  <action>
    Update `apps/portal/src/components/DocumentTabs.tsx` to add swipe gestures:

    1. Import the swipe hook:
    ```typescript
    import { useSwipe } from '../hooks/useTouchGesture';
    ```

    2. Add swipe handlers to the main tab bar container:
    ```typescript
    // In DocumentTabs component, add:
    const swipeHandlers = useSwipe({
      onSwipeLeft: () => {
        // Switch to next tab
        const currentIndex = tabs.findIndex((t) => t.id === activeTabId);
        if (currentIndex < tabs.length - 1 && currentIndex >= 0) {
          onTabClick(tabs[currentIndex + 1].id);
        }
      },
      onSwipeRight: () => {
        // Switch to previous tab
        const currentIndex = tabs.findIndex((t) => t.id === activeTabId);
        if (currentIndex > 0) {
          onTabClick(tabs[currentIndex - 1].id);
        }
      },
    });
    ```

    3. Apply handlers to the tab bar div:
    ```typescript
    <div
      className="document-tabs flex items-center gap-1 px-2 py-1 bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 overflow-x-auto"
      {...swipeHandlers}
    >
    ```

    This enables swipe navigation between tabs on mobile.
  </action>
  <verify>DocumentTabs has swipe gestures</verify>
  <done>Added swipe gestures to tabs</done>
</task>

<task type="auto">
  <name>Update AnnotationExport for touch</name>
  <files>apps/portal/src/components/AnnotationExport.tsx</files>
  <action>
    Review and update `apps/portal/src/components/AnnotationExport.tsx` for touch:

    1. Check all buttons meet 44x44px minimum
    2. Add touch-friendly padding to interactive elements
    3. Ensure form inputs have proper touch targets
    4. Add :active states for visual feedback

    Specific changes:
    - Increase button heights to min-h-[44px]
    - Increase padding on touch targets
    - Add active:scale-95 for tap feedback
    - Ensure dropdown items have min-h-[44px]

    Make the annotation panel touch-friendly.
  </action>
  <verify>AnnotationExport touch-optimized</verify>
  <done>Optimized annotations for touch</done>
</task>

</tasks>

<verification>
- [ ] useSwipe detects left/right/up/down swipes
- [ ] useLongPress detects long press with threshold
- [ ] usePullToRefresh implements pull-to-refresh
- [ ] TouchButton has 44x44px minimum tap targets
- [ ] TouchIconButton accessible with aria-label
- [ ] DocumentTabs supports swipe navigation
- [ ] AnnotationExport buttons are touch-friendly
- [ ] Active states provide visual feedback
</verification>

<success_criteria>
1. Touch targets meet minimum size requirements
2. Swipe gestures work for tab switching
3. Long-press can be used for context actions
4. Touch interactions feel native and responsive
</success_criteria>

---

**Plan created:** 2026-02-06
**Estimated duration:** 25 min
**Complexity:** Medium (gesture recognition, touch target sizing, mobile UX)
